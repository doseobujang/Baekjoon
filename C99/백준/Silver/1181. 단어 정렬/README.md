# [Silver V] 단어 정렬 - 1181 

[문제 링크](https://www.acmicpc.net/problem/1181) 

### 성능 요약

메모리: 2308 KB, 시간: 24 ms

### 분류

문자열, 정렬

### 제출 일자

2026년 2월 21일 08:48:14

### 문제 설명

<p>알파벳 소문자로 이루어진 N개의 단어가 들어오면 아래와 같은 조건에 따라 정렬하는 프로그램을 작성하시오.</p>

<ol>
	<li>길이가 짧은 것부터</li>
	<li>길이가 같으면 사전 순으로</li>
</ol>

<p>단, 중복된 단어는 하나만 남기고 제거해야 한다.</p>

### 입력 

 <p>첫째 줄에 단어의 개수 N이 주어진다. (1 ≤ N ≤ 20,000) 둘째 줄부터 N개의 줄에 걸쳐 알파벳 소문자로 이루어진 단어가 한 줄에 하나씩 주어진다. 주어지는 문자열의 길이는 50을 넘지 않는다.</p>

### 출력 

 <p>조건에 따라 정렬하여 단어들을 출력한다.</p>

### 시행착오 with Gemini
#### 1. 메모리와 포인터의 구조적 오해 (Memory & Pointers)
- 초기화되지 않은 쓰레기 값으로 배열 선언 (Segfault): scanf로 크기 n을 입력받기도 전에 char str[n][51]을 선언하여 프로그램이 시작하자마자 메모리가 붕괴되는 치명적인 실수가 있었습니다.
- 주소와 값의 혼동 (데이터 파괴): 문자열의 순서를 바꾸기 위해 포인터의 '주소'를 교체해야 하는데, 이중 포인터를 두 번 역참조(**a = **b)하여 두 단어의 첫 번째 글자만 뜯어서 맞바꾸는 데이터 훼손이 발생했습니다.
- 논리 연산자 단락 평가의 맹점 (Out of Bounds): while (strlen(str[j]) >= strlen(str[i]) && j >= 0)처럼, 방어벽인 j >= 0보다 메모리 접근인 strlen(str[j])을 먼저 검사하도록 작성하여 음수 인덱스를 침범하고 세그먼테이션 폴트를 일으켰습니다.

#### 2. 퀵 정렬(Quick Sort) 로직의 붕괴 (Algorithm Fallacies)
- 재귀의 기본(Base Condition) 망각: 재귀 함수에서 분할 크기가 1 이하일 때 탈출하는 if (start >= end) return; 조건을 누락하여 스택 오버플로우를 발생시켰습니다.
- 포인터 교착 상태 (Deadlock): 조건문 설정 오류로 left와 right 포인터가 서로를 엇갈려 지나가지(Cross) 못하고 제자리에 갇혀, 자기 자신과 끝없이 자리를 바꾸는 무한 루프에 빠졌습니다.
- 파티션 경계 침범: right 포인터가 하한선을 지키지 못하고 (right > 0으로 고정), 자신이 정렬해야 할 범위를 넘어 남의 구역(이미 정렬된 앞쪽 배열)까지 쳐들어가 데이터를 다시 섞어버렸습니다.

#### 3. 효율성 파탄 및 시간 초과 (Time Limit Exceeded)
- 고정된 피벗이 부른 최악의 시간 복잡도 ($O(N^2)$): 피벗을 항상 배열의 맨 앞(start)으로 고정했습니다. 이는 이미 정렬된 데이터가 들어왔을 때 배열이 반으로 쪼개지지 않고 극단적으로 편향되어, 퀵 정렬이 가장 느린 알고리즘으로 전락하는 원인이 되었습니다.
- 숨 쉴 때마다 길이를 재는 strlen의 낭비: 단어의 길이는 정렬 중 변하지 않음에도, 반복문이 한 칸 돌 때마다 $O(L)$의 비용이 드는 strlen을 매번 호출하여 수천만 번의 무의미한 연산 부하를 일으켰습니다.
- 변수 캐싱의 역설: strlen의 부하를 줄이려고 길이를 변수에 담아두었으나, swap으로 문자열의 자리가 바뀐 뒤에 변숫값을 갱신하지 않아 프로그램이 과거의 환영(잘못된 길이)에 속아 무한 루프에 빠졌습니다.

#### 4. 문자열 처리와 요구사항 필터링 (String Handling)
자멸하는 중복 검사: 중복을 제거하겠다며 이중 루프를 돌다가, 자기 자신과 비교(!strcmp(str[i], str[i]))하여 출력을 스스로 막아버리는 논리적 결함이 있었습니다. (최종적으로 정렬 완료 후 str[i]와 str[i-1] 단 한 번만 비교하는 정석적인 구조로 해결함).
