# [Silver V] 나이순 정렬 - 10814 

[문제 링크](https://www.acmicpc.net/problem/10814) 

### 성능 요약

메모리: 13488 KB, 시간: 56 ms

### 분류

정렬, 집합과 맵

### 제출 일자

2026년 2월 21일 20:49:20

### 문제 설명

<p>온라인 저지에 가입한 사람들의 나이와 이름이 가입한 순서대로 주어진다. 이때, 회원들을 나이가 증가하는 순으로, 나이가 같으면 먼저 가입한 사람이 앞에 오는 순서로 정렬하는 프로그램을 작성하시오.</p>

### 입력 

 <p>첫째 줄에 온라인 저지 회원의 수 N이 주어진다. (1 ≤ N ≤ 100,000)</p>

<p>둘째 줄부터 N개의 줄에는 각 회원의 나이와 이름이 공백으로 구분되어 주어진다. 나이는 1보다 크거나 같으며, 200보다 작거나 같은 정수이고, 이름은 알파벳 대소문자로 이루어져 있고, 길이가 100보다 작거나 같은 문자열이다. 입력은 가입한 순서로 주어진다.</p>

### 출력 

 <p>첫째 줄부터 총 N개의 줄에 걸쳐 온라인 저지 회원을 나이 순, 나이가 같으면 가입한 순으로 한 줄에 한 명씩 나이와 이름을 공백으로 구분해 출력한다.</p>

**[구조체 기반 정렬 문제 시행착오 요약]**

**1. 포인터 배열과 qsort 보폭(Stride) 불일치**

* **문제:** 구조체 포인터 배열(`Node* lst[n]`)을 선언하고, `qsort`의 원소 크기에 구조체 전체 크기(`sizeof(Node)`)를 전달. 추가로 `compare` 함수에서 이중 포인터(`Node**`)를 단일 포인터(`Node*`)로 잘못 캐스팅해 주솟값을 데이터로 읽음. (Segmentation Fault 발생)
* **해결:** 연속된 메모리를 갖는 구조체 배열(`Node lst[n]`)로 변경하여 이중 포인터 캐스팅 문제와 메모리 파편화를 동시에 제거.

**2. qsort 단일 원소 크기 지정 오류**

* **문제:** `qsort`의 3번째 매개변수(단일 원소의 크기)에 배열 전체 크기(`sizeof(Node) * n`)를 전달. 정렬 포인터가 배열 범위를 이탈함. (Segmentation Fault 발생)
* **해결:** 매개변수를 `sizeof(Node)`로 수정하여 탐색 보폭을 단일 구조체 크기로 정상화.

**3. scanf 메모리 주소 전달 오류**

* **문제:** `scanf`로 값을 받을 때 구조체 주소를 잘못 전달함. (`lst[i]`를 그대로 쓰거나, 이미 포인터인 배열 `name`에 `&`를 붙임)
* **해결:** `&lst[i].age`, `lst[i].name`으로 각 멤버 타입에 맞는 정확한 메모리 주소를 전달하도록 수정.

**4. 불안정 정렬(Unstable Sort) 한계**

* **문제:** C언어 `qsort`는 값이 같을 때 기존 입력 순서를 보장하지 않는 불안정 정렬임.
* **해결:** 구조체 내부에 입력 순서를 기억하는 `order` 변수를 추가하고, `compare`에서 나이가 같을 경우 `order`를 비교하게 하여 안정 정렬(Stable Sort)의 조건을 충족시킴.

**5. 가변 길이 배열(VLA)의 메모리 한계 (잠재적 위험)**

* **문제:** `Node lst[n];` 방식은 스택(Stack) 영역을 사용하므로, 입력값 `n`이 매우 커지면 스택 오버플로우가 발생함.
* **해결 (향후 방향):** 대규모 데이터 정렬 시 `Node* lst = (Node*)malloc(sizeof(Node) * n);`을 사용하여 힙(Heap) 영역에 동적 할당하는 방식으로 구현해야 함.
